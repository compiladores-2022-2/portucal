declrs{
    proc wmerge(arr: int[10], i : int, m : int, j : int, n : int, w : int){
        enquanto(i < m e j < n){
            se(arr[i] < arr[j]){
                troca(arr, w + 1, i + 1)
            } senao{
                troca(arr, w + 1, j + 1)
            }
        };
        enquanto(i < m){
            troca(arr, w + 1, i + 1)
        };
        enquanto(j < n){
            troca(arr, w + 1, j + 1)
        }
    };

    func troca(arr : int[10], i : int, j : int) : int[10]{
        declrs{
            var temp : int
        }
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        retorne arr
    };

    proc wsort(arr: int[10], l : int, u : int, w : int){
        declrs{
            var m : int
        }
        se(u - l > 1){
            m = l + (u - l)/2;
            imsort(arr, l, m);
            imsort(arr, m, u);
            wmerge(arr, l, m, m, u, w)
        } senao{
            enquanto(l < u){
                troca(arr, l + 1, w + 1)
            }
        }
    };

    proc imsort(arr : int[10], l : int, u : int){
        declrs{
            var m, n, w : int
        }
        se(u - l > 1){
            m = l + (u - l) / 2;
            w = l + u - m;
            wsort(arr, l, m, w);
            enquanto(w - l > 2) {
                n = w;
                w = l + (n - l + 1) / 2;
                wsort(arr, w, n, l);
                wmerge(arr, l, l + n - w, n, u, w)
            };
            para (n = w; n > l; n = n - 1){
                para (m = n; m < u e arr[m] < arr[m - 1]; m = m + 1){
                    troca(arr, m, m - 1)
                }
            }
        }
    }
}

bloco{
    continue
}